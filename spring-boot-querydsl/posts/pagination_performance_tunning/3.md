# 3. 페이징 성능 개선하기 - Count 쿼리 최소화하기 

앞서 포스팅에서 실질 페이징 쿼리 성능을 올리는 방법들을 소개 드렸는데요.

* [1. 페이징 성능 개선하기 - No Offset 사용하기](https://jojoldu.tistory.com/528)
* [2. 페이징 성능 개선하기 - 커버링 인덱스 사용하기](https://jojoldu.tistory.com/529)

페이징 기능을 구현하는데 있어, 페이징 쿼리 자체를 개선하는 것도 방법이지만 **그 외 다른 기능을 개선하는 방법**도 함께할 수 있습니다.  
  
여기서 말하는 그 외 기능이라하면 바로 **count 쿼리**입니다.  
일반적인 페이징 기능에 있어 데이터 조회와 함께 매번 함께 수행되는 것이 바로 count 쿼리인데요.  
  
**전체 몇 페이지**가 노출되어야할지 알아야 아래와 같이 pageNo들을 노출시킬 수 있기 때문입니다.

![count_no](./images/3/count_no.png)

> 당연히 [No Offset](https://jojoldu.tistory.com/528)을 사용한다면 사용되지 않는 쿼리입니다.


* 첫 페이지 조회시 page count를 고정하고, 2번째 페이지 이상 사용하게 되면 실제 page count를 사용하기 (구글검색결과처럼)
  * 페이지 조회가 첫 페이지에 집중된 경우
* 첫 페이지 조회 결과를 cache하기
  * 페이지 조회가 첫 페이지 외에도 많인 발생하는 경우

## 3. Count 쿼리 결과 Cache하기 

> [count 쿼리 성능 이슈](https://jojoldu.tistory.com/516)

```sql
select
    book0_.id as id1_3_,
    book0_.book_no as book_no2_3_,
    book0_.book_type as book_typ3_3_,
    book0_.name as name4_3_ 
from
    book book0_ 
where
    book0_.book_type=? 
order by
    book0_.id desc limit ?, ?
```

불필요한 ```order by``` 와 ```select``` 을 제외해서 count쿼리를 실행해줍니다.

```sql
select
    count(book0_.id) as col_0_0_ 
from
    book book0_ 
where
    book0_.book_type=?
```

where로 걸러진 데이터가 1000만건, 1억건이여도 다 row를 읽어서 count를 구하기 때문입니다.  

### 3-1. 구현 코드 - 직접 Paging 

### 3-2. 구현 코드 - QuerydslSupport

### 3-3. 단점

* 실시간으로 데이터 수정이 필요해 페이지 버튼 반영이 필요한 경우 사용할 수 없습니다.
  * 결국 새로고침 (or 버튼 클릭을 통한 페이지 이동) 하기 전까지는 페이지 버튼들이 계속 그대로 유지 되기 때문에 실시간성이 떨어집니다.
  * 마감된 데이터 혹은 실시간을 유지할 필요 없을 경우에만 사용할 수 있습니다.

