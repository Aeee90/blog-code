[IntelliJ 블로그](https://blog.jetbrains.com/idea/2017/08/code-smells-iteration/)에 올라온 시리즈물을 번역 & 재정리 하였습니다. 

![0_로고](./images/0_로고.png)

# 4. Code Smells: 값의 가변성 (변경가능한 값)

[심하게 중첩된 코드](http://jojoldu.tistory.com/177)글에서 저는 ```getMappedField``` 메소드의 리턴 타입을 ```Optional```로 변경하고 싶었습니다.  
변경자체는 굉장히 사소한 일이지만, 그 메소드를 호출하는 코드들의 변경은... 음 또다른 문제였습니다.  
  
 ```validateQuery```에서 이 메소드가 사용되는 여러 장소중 하나는 예상했던 것보다 훨씬 더 복잡한 메소드였습니다.  
 ```getMappedField```를 ```Optional```로 변경하려고 할때, 놀라울 정도로 많은 Null 체크 코드를 ```isPresent```로 변경했습니다.

![4_is_present](./images/4_is_present.png)

이게 전부가 아닙니다.  
이 메소드는 거의 100라인이라 1개의 캡쳐화면에 전부 담을수가 없었습니다. (이것 역시 다른 글의 주제가 될 예정입니다.)  
**```Optional```은 전혀 Null 체크 문제를 해결하지 못할뿐더러, 체크 코드의 추가와 관련된 것을 가져오는 것까지 더해져 코드를 더 흉측하게** 만들어버린다는 것에 저는 짜증이 났습니다.  
그러나 이것은 더 근본적인 문제의 징후였습니다.

### 냄새: 가변성

이 메소드는 1개 이상의 악취가 나기에 충분할만큼 긴 코드를 가졌습니다.  
이번 글에서 저는 얘기했던대로 첫번째 이슈에 초점을 맞추겠습니다.  
  
 ```mf```는 **변수**입니다.  
이것은 가변적인 값이며 어떤 경우엔 재할당되기도 합니다.  
만약 ```mf```가 final로 만든다면 아래와 같은 코드가 됩니다.

![4_field_final](./images/4_field_final.png)

만약 ```getMappedField``` 메소드가 값을 리턴하지 않는다면 mf는 ```getMappedFieldByJavaField```를 통해 값을 할당받아야 합니다.  
  
이 글을 보고 계신 분들은 이 특정 코드의 문맥에 대해 명확하게 알고 있지 않다고 가정하지만, 솔직히 말해서 저 역시 이 프로젝트를 몇년 동안 계속해서 해왔지만 그 중 무엇을 하고 있는지 이해하지 못합니다.  
  
이것이 개발자가 되는 것입니다.  
코드를 작성하기가 어렵고, 코드를 읽는 것은 더 어렵습니다.  
  
어쨌든,  
  
요점은 **```mf```의 값은 변경되고 있으며, 이로 인해 추론하기가 더욱 어렵습니다.**  
예를 들어 코드의 뒷부분에서 값을 검사 할 때 값이 비어 있으면 ```getMappedField```가 값을 반환하지 않았거나, ```getMappedFieldByJavaField```가 값을 반환하지 않았기 때문에 ```mf```값이 비어 있는지 알 수가 없습니다.  
값이 비어있지만, **비어있다는 것이 무엇을 의미하는지 알수 없다는 것**입니다.  
  
이 특별한 문제는 해당 로직을 이동시키고, 유용한 변수명으로 값을 재할당을 하는 등으로 해결할 수 있을것 같습니다.  
그러면 변수가 무엇인지, 그리고 왜 그것이 존재할 수도 있고 존재하지 않을 수도 있는지에 대해 작은 아이디어를 얻을지도 모릅니다.  
  
IntelliJ IDEA에서 이 코드를 메소드로 추출하면 ...

![4_extract_method](./images/4_extract_method.png)

(```command+option+m```)  
  
이렇게 **변경 가능한 1개 이상의 값**들이 있어 수행할 수 없습니다.  
  
여기서는 ```pathElements```배열 내부의 값을 수정하고 있습니다.  
우리가 이 배열을 파라미터로 전달하고 메서드에서 변경할 수 있기 때문에 이것이 리팩토링을 막을수는 없지만 이 값을 변경하는 데는 문제가 있습니다.  
  
메소드를 추출할 수 없는 수정은 특정 상황에서 ```hasTranslations``` 플래그가 true로 될 경우입니다.  
 true로 설정된 경우 다른값을 수정해야 합니다.

![4_has_translations](./images/4_has_translations.png)

이 코드를 좀 더 자세히 살펴보면 아래 내용이 궁금하게 됩니다.

* ```origProp```의 값을 변경하는 것일까요? 
  * 변경후에 더이상 원래의 속성이 유지되지 않습니다.

* 왜 ```StringBuilder```를 재사용하고 재설정할까요? 
  * 새로운 String 값을 사용하거나 일부 도메인 객체에서 String 값을 설정하는 것보다 더 이상한 일처럼 보입니다.

 ```StringBuilder``` 이 코드가 의도적으로 파라미터 값을 변경하기 때문에 변경하려고 합니다.  
 이 코드는 길고 복잡한 메서드 내에서 **상태를 설정하기 위해 가변성을 많이 사용**할 뿐만 아니라 **Java가 다중 출력 값을 지원하지 않기 때문에 파라미터의 값을 실제로 변경**합니다.  
 이는 괜찮은 절충안으로 보입니다.  
 (참고 : 이렇게 생각하시면 안됩니다.)  
   
  
값의 가변성으로 인해 발생하는 문제를 요약하면 다음과 같습니다.

1. ```mf```의 가변성으로 인해 **뒤에 있는 복잡한 논리를 추론하기가 어렵**습니다.

2. 메소드에서 **나중에 사용할 boolean 플래그 값을 설정**하면 코드 섹션을 보다 읽기 쉬운 작은 메소드로 추출하는 것이 매우 어려워집니다.

3. 파라미터 값을 변경하면 해당 메서드는 복잡해지고, 메소드의 호출자는 높은 확률로 놀라게 됩니다. - 일반적으로 파라미터 값을 메서드에 전달할 때 **파라미터 값이 변경되는 것을 기대하지 않습니다**.

저희는 이런 상황에서 리팩토링하기가 매우 어렵고 길고 복잡하며 이해하기 어려운 메소드를 가지고 있습니다.  
그리고 이것은 이 코드에서 변경 가능성 냄새를 보고있는 것입니다.  
  
유사하지만 관련이 없는 예제를 보여준 이전 글과 달리 이 글의 리팩토링 제안은 순서대로 수행해야하는 일련의 단계로 이루어집니다.  
이 단계는 처음 시도한 것이 아닐 수 있지만 (시도한 첫 번째 아이디어가 아닐 수 있습니다), 한 번에 하나의 작은 문제를 해결하고 코드에 가능한 한 적은 영향을 미치려고 합니다.

[[ad]]

### 1 단계 : 반복되는 배열의 변형을 중지합니다.

우선 해결해야할 첫 번째 문제는 ```pathElements``` 배열의 가변성입니다.  
 ```pathElements```의 값을 변경하는 코드를 제거함으로써, 저는 다음과 같은 내용을 기대합니다.

1. 배열, Collection을 변경하는 다소 불쾌한 냄새 제거
2. ```hasTranslations``` 플래그의 필요성 제거 

2번째 기대는 이 막대한 코드 중 일부를 간단한 방법으로 추출하여 **```mf```변수의 가변성을 간단하고 단순한 방법으로 제한**하는 데 도움이됩니다.  
  
먼저 새 값을 저장하기 위해 원래의 객체를 변경하는 대신 새 값을 저장하는 다른 객체를 소개합니다.  
여기서 저는 ```List```를 선택하겠습니다.  
콜렉션을 사용하기를 좋아하고, Streams는 나중에 이 메소드에서 사용할 좋은 기능을 제공하기 때문입니다.  
저는 문자열 배열을 쉽게 선택했는데, 이는 완전히 개인적인 선택입니다.  
(성능을 위해 가독성을 거래 할 수 있습니다. 이는 사용자 코드에 따라 선택하시면 됩니다.)

![4_string_array](./images/4_string_array.png)

원본 ```pathElements```배열이 만들어진 같은 위치에 이 컬렉션을 만들고 초기화합니다.  
동일한 값으로 초기화 할 것입니다.  
  
다음으로 ```pathElements```을 변경한 곳에서  ```databasePathElements```의 값을 변경하려고 합니다.  
지금은 코드가 깨지는 것을 최소화하기 위해 두 가지 변경을 계속 수행하겠습니다.

![4_database_set](./images/4_database_set.png)

마지막으로, ```pathElements``` 대신에 ```databasePathElements```를 사용하여 ```StringBuilder``` ```origProp```의 새 값을 설정합니다.  

![4_set_database](./images/4_set_database.png)

Java 8에서 가장 좋아하는 기능 중 하나인 ```Collectors.joining```를 사용했습니다.  
이렇게하면 5줄의 코드가 한 줄로 대체되었으므로 CSV 내용을 생성하거나, 콜렉션을 ```.```으로 구분 된 문자열로 변환하는 데 정말 유용합니다.  
이 메소드의 성능은 원래 코드와 다를 수 있으며 (추가로 우리는 배열 대신 콜렉션을 사용합니다), 따라서 나노 초 성능이 중요하다면 성능 테스트를 수행해야합니다.  
대부분의 어플리케이션에서 그 영향은 미미할 것으로 예상하고 새로운 구문은 반복적으로 사용되는 코드를 줄입니다.  
  
모든 테스트를 실행하면 모든 것이 여전히 통과됩니다.  
다시 돌아가서 ```pathElement```변경된 코드를 제거합니다.  
(IntelliJ IDEA의 라인넘버가 있는 곳의 파란색 영역을 클릭하여 이전 코드와 새 코드를 비교했습니다.)

![4_1_final](./images/4_1_final.png)

테스트를 다시 실행하면 이전과 마찬가지로 모든 작업이 수행되는 것을 볼 수 있습니다.  
  
이것은 약간의 변화이며 오류의 가능성을 최소화하기 위해 이 메소드의 내부에만 영향을 미치도록 제한했습니다.  
약간 무의미해 보일지 모르지만 이 메소드의 복잡성을 줄이는 1단계입니다.

[[ad]]

### 2 단계 : hasTranslations 플래그 제거

