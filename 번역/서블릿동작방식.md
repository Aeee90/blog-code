# 서블릿의 인스턴스화, 세션, 다중스레딩에 관련된 질문과 답변에 대한 번역
스택오버플로우에 올라온 서블릿과 관련된 [질문](http://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreadi)에 아주 좋은 답변이 달린 것을 보고 이건 번역 하면 좋겠다는 생각에 첫 번역을 시작하게 되었습니다.  
영어를 너무 너무 못하지만 그래도 시작이 반이라고 생각되기에 일단! 시작하였습니다. (구글신을 믿습니다.)  
참고로 인스턴스화 라는 것은 **해당 클래스의 구현** 이라고 생각하시면 됩니다.  
```
Member m = new Member
// m은 Member 클래스의 인스턴스(객체가 아니에요)
// 이 생성 과정을 Member 클래스의 인스턴스화
```

혹시나 아래 번역이 부족하여 이해가 더 안되신다면 [구루비의 글](http://wiki.gurubee.net/pages/viewpage.action?pageId=26740202)을 읽어보시면 도움이 되실것 같습니다.


### 질문)
다수의 서블릿이 있는 웹서버가 있습니다. 해당 서블릿들 간에 전달되는 값들은 세션 변수와 인스턴스 변수에 할당해서 사용하고 있습니다.  
이 상황에서 만약 2명 혹은 그 이상의 사용자가 이 웹 서버에 request를 보내면 세션 변수는 어떻게 되는 건가요?  
모든 사용자가 동일한 세션변수를 사용하는 것인가요?  
아니면 각 사용자마다 세션변수가 다른가요?  
서로 다르다면 서버는 다른 사용자를 어떻게 구별할 수 있는건가요?  

한가지 더 비슷한 질문으로, 특정 서블릿에 접근하는 n명의 사용자가 있는 경우 이 서블릿은 첫번째 사용자가 처음 엑세스 했을때만 인스턴스화 되는건가요, 아니면 모든 사용자에게 개별적으로 인스턴스화 되는건가요?  
즉, 인스턴스 변수는 어떻게 되는건가요?  

### 답변)
#### ServletContext
서블릿 컨테이너(아파치 톰캣과 같은)가 시작되면, 해당 서블릿 컨테이너는 모든 웹 어플리케이션들을 배포하고 로드(load)합니다.  
웹 어플이케이션이 로드되면 서블릿 컨테이너는 ServletContext를 한번 생성하여, 서버의 메모리에 보관합니다.  
이후 web.xml을 파싱하여 ```<sevlet>```, ```<filter>```, ```<listener>``` 가 발견되면 (혹은 ```@WebServlet```, ```@WebFilter```, ```@WebListener``` 어노테이션들로 지정된 클래스들) 해당 클래스들을 **한번** 인스턴스 생성을 하고 서버의 메모리에 보관합니다.  
각각의 인스턴스화 된 필터는 본인의 ```init()```메소드가 즉시 실행(invoked)됩니다.  

서블릿 컨테이너가 종료되면 모든 웹 어플리케이션들을 언로드(unload)하고, 모든 초기화된 서블릿 및 필터의 ```destory()``` 메소드를 실행후 ```ServletContext```, ```Servlet```, ```Filter``` 및 ```Listener``` 인스턴스들은 전부 삭제됩니다.  

서블릿에 0보다 큰 ```<servlet>``` ```<load-on-startup>``` 또는 ```@WebServlet(loadOnStartup)``` 값이 있을 경우 ```init()``` 메소드도 시작 중에 즉시 실행 됩니다.  
이러한 서블릿은 해당 값(1이면 첫번째, 2이면 두번째)에 지정된 순서대로 초기화 됩니다.  
1개 이상의 서블릿이 동일한 값을 가지고 있을 경우엔 web.xml 또는 ```@WebServlet``` 클래스로딩에 등장하는 순서대로 로드됩니다.  
만약 ```load-on-startup```값이 없을 경우엔 해당 서블릿에 **처음으로 HTTP request가 올때** ```init()```메소드가 실행됩니다.  

#### HttpServletRequest 및 HttpServletResponse
서블릿 컨테이너는 특정 포트 번호(8080포트는 일반적으로 개발단계에서 사용되고, 프로덕션(실서버)환경에서는 80포트)에서 HTTP request를 받는(listens) 웹 서버에 연결됩니다.  
클라이언트(웹 브라우저를 가진 사용자)가 HTTP request를 보낼 때, 서블릿 컨테이너는 새로운 HttpServletRequest와 HttpServletResponse 인스턴스를 생성하고 해당 인스턴스를 미리 정의된 필터 체인과 서블릿 인스턴스를 통과하도록 합니다.  

필터의 경우 ```doFilter()```메소드가 호출됩니다. ```chain.doFilter(request, response)```를 호출하면 request와 response가 다음 필터로 넘어가거나, 남아있는 필터가 없는 경우 서블릿에 도달합니다.

서블릿의 경우 ```service()```메소드가 호출됩니다. 기본적으로 이 메소드는 ```request.getMethod()``` 메소드를 기반으로 호출할 ```doXXX(): doGet, doPost등``` 메소드 중 하나를 결정합니다. 해당되는 메소드가 서블릿에 없으면 면 response에 HTTP 405 에러가 리턴됩니다.  

request 객체는 header와 body 같은 HTTP request에 대한 모든 정보를 갖고 있습니다.  
response 객체는 예를 들어 header와 body(일반적으로 JSP 파일에서 생성된 HTML 내용)을 설정하는 것처럼 당신이 원하는 방식으로 HTTP 응답을 보낼 수 있는 기능을 제공합니다.        
HTTP 응답이 완료되면 request 객체와 response객체는 모두 재활용되어 재사용 할 수 있습니다.  

#### HttpSession
When a client visits the webapp for the first time and/or the HttpSession is obtained for the first time via request.getSession(), the servlet container creates a new HttpSession object, generates a long and unique ID (which you can get by session.getId()), and store it in the server's memory. The servlet container also sets a Cookie in the Set-Cookie header of the HTTP response with JSESSIONID as its name and the unique session ID as its value.

As per the HTTP cookie specification (a contract a decent web browser and web server have to adhere to), the client (the web browser) is required to send this cookie back in subsequent requests in the Cookie header for as long as the cookie is valid (i.e. the unique ID must refer to an unexpired session and the domain and path are correct). Using your browser's built-in HTTP traffic monitor, you can verify that the cookie is valid (press F12 in Chrome / Firefox 23+ / IE9+, and check the Net/Network tab). The servlet container will check the Cookie header of every incoming HTTP request for the presence of the cookie with the name JSESSIONID and use its value (the session ID) to get the associated HttpSession from server's memory.

The HttpSession stays alive until it has not been used for more than the timeout value specified in <session-timeout>, a setting in web.xml. The timeout value defaults to 30 minutes. So, when the client doesn't visit the web app for longer than the time specified, the servlet container trashes the session. Every subsequent request, even with the cookie specified, will not have access to the same session anymore; the servlet container will create a new session.

On the client side, the session cookie stays alive for as long as the browser instance is running. So, if the client closes the browser instance (all tabs/windows), then the session is trashed on the client's side. In a new browser instance, the cookie associated with the session wouldn't exist, so it would no longer be sent. This causes an entirely new HTTPSession to be created, with an entirely new session cookie begin used.

### In a nutshell
The ServletContext lives for as long as the web app lives. It is shared among all requests in all sessions.
The HttpSession lives for as long as the client is interacting with the web app with the same browser instance, and the session hasn't timed out at the server side. It is shared among all requests in the same session.
The HttpServletRequest and HttpServletResponse live from the time the servlet receives an HTTP request from the client, until the complete response (the web page) has arrived. It is not shared elsewhere.
All Servlet, Filter and Listener instances live as long as the web app lives. They are shared among all requests in all sessions.
Any attribute that is defined in ServletContext, HttpServletRequest and HttpSession will live as long as the object in question lives. The object itself represents the "scope" in bean management frameworks such as JSF, CDI, Spring, etc. Those frameworks store their scoped beans as an attribute of its closest matching scope.

#### Thread Safety
That said, your major concern is possibly thread safety. You should now know that servlets and filters are shared among all requests. That's the nice thing of Java, it's multithreaded and different threads (read: HTTP requests) can make use of the same instance. It would otherwise be too expensive to recreate, init() and destroy() them for every single request.

You should also realize that you should never assign any request or session scoped data as an instance variable of a servlet or filter. It will be shared among all other requests in other sessions. That's not thread-safe! The below example illustrates this:

```
public class ExampleServlet extends HttpServlet {

    private Object thisIsNOTThreadSafe; //쓰레드에 안전하지 않은 변수

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Object thisIsThreadSafe; // 쓰레드에 안전한 지역변수

        thisIsNOTThreadSafe = request.getParameter("foo"); // BAD!! 모든 request가 공유합니다.
        thisIsThreadSafe = request.getParameter("foo"); // OK, 이건 쓰레드에 안전합니다.
    }
}
```

### 답변에 달린 참고
[What is the difference between JSF, Servlet and JSP?](http://stackoverflow.com/questions/2095397/what-is-the-difference-between-jsf-servlet-and-jsp)
[Best option for Session management in Java](http://stackoverflow.com/questions/1700390/best-option-for-session-management-in-java)
[Difference between / and /* in servlet mapping url pattern](http://stackoverflow.com/questions/4140448/difference-between-and-in-servlet-mapping-url-pattern)
[doGet and doPost in Servlets](http://stackoverflow.com/questions/2349633/doget-and-dopost-in-servlets)
[Servlet seems to handle multiple concurrent browser requests synchronously](http://stackoverflow.com/questions/8011138/servlet-seems-to-handle-multiple-concurrent-requests-synchronously/)
[Why Servlets are not thread Safe?](http://stackoverflow.com/questions/9555842/why-servlets-are-not-thread-safe/)
