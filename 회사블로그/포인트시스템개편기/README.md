# 포인트 시스템 개편기 #1 - 개발

올해 4월 중순부터 시작해 7월말까지 진행된 포인트 시스템을 개편했던 경험을 공유하려고 합니다.  

## 기술 스택

* Java 8
* Querydsl 4.x
* Junit 4 & Spock
* Spring Boot 2.x
* Spring Cloud 2.x
* AWS Beanstalk
* AWS Aurora RDS
* AWS Elastic Cache Redis
* AWS SQS

## 도메인

**Update와 Delete가 없는 도메인**으로 구성하였습니다.  
특히 포인트는 일종의 기업 부채 혹은 재화와 비슷한 의미로 사용되기 때문에 그 이력은 아주 정확하고 상세하게 관리되어야만 했습니다.  
  


## 시스템 아키텍처

이번 포인트 시스템의 아키텍처 기조는 **DB가 죽어도 문제 없는 서비스**였습니다.

* RDS가 죽어도 SQS에는 이벤트 메세지들이 쌓여 있기 때문에 RDS가 복구되는 순간 처리 가능
* 가장 많이 사용되는 포인트 조회는 Redis 캐시를 통해 처리되니 RDS가 죽어도 시스템 문제가 없음
* Redis가 죽는 장애가 발생하면 바로 RDS를 통해 조회가 되도록 구성

특히 포인트 시스템을 가장 중요하게 사용하는 주문 시스템과 결제 시스템은 마찬가지로 SQS로 비동기 시스템이 구축되어 있습니다.  
그래서 포인트의 모든 서비스가 죽는다 하더라도, 주문 시스템과 결제 시스템은 SQS에 메세지를 계속 담아두고 포인트 시스템이 다시 실행되면 그때 메세지를 일괄 발송하면 되므로 고가용성 시스템을 구축할 수 있었습니다.

![아키텍처1](./images//아키텍처1.png)

여기서 한가지 다른 점은 **포인트 사용은 SQS를 쓰지 않고 바로 데이터베이스에 반영한다**는 점입니다.  

스프링 배치를 통한 이벤트 처리 역시 point-edge 모듈을 통해서 처리되도록 했습니다.
포인트 차감이 즉시 되지 않으면, 포인트 중복 사용이 발생할 수 있음
포인트 사용 취소, 포인트 적립, 포인트 적립 취소, 포인트 전환은 큐를 통해 이벤트 등록한다

**SQS는 순서가 보장되지 않습니다**.  
그래서 주문하고 바로 취소를 할 경우 상황에 따라 취소가 먼저 오고, 적립이 이후에 올 수 있습니다.  
이럴 경우 적립된 대상이 아직 없기 때문에 취소 이벤트는 실패하게 됩니다.  

취소할 대상이 없는 경우 Ack처리하지 않는다 (다시 SQS로 돌려보낸다라는 의미입니다) 로 문제를 해결했습니다.  
같은 메세지가 5번 실패하면 Dead Letter Queue로 반환되기 때문에 5번 취소대상을 찾았는데도 실패했다면 진짜 잘못된 메세지로 보는 것입니다.


### RDS R3 vs R4

## 테스트

### 단위 테스트와 통합 테스트

단위 테스트 & 통합 테스트 도구로는 **Junit4**와 **Spock**을 같이 사용했습니다.  
코드 리뷰 시간에 철저히 Feature 테스트 코드를 점검하기 때문에 단위 테스트 없이 절대 Merge 할 수는 없습니다.  
테스트 도구의 경우 Spock으로 점차 넘어가는 중이지만, 아직 Junit4가 익숙하신분이 계셔 Junit4를 사용해도 무방하다는 룰을 정했습니다.  
Spock을 연습하면서 프로젝트를 진행하기에는 시간이 그렇게 넉넉하지 않았기 때문입니다.  
  


### Spring Cloud & AWS 테스트

신규 포인트 프로젝트의 큰 기조 중 하나는 "**Git Clone 받으면 바로 로컬 개발 환경 & 테스트가 실행될 수 있어야 한다**" 입니다.  
프로젝트 받은 뒤에 A도 해야하고, B도 해야하고, C도 해야만 테스트를 돌려볼 수 있고, 로컬에서 서버를 올릴수 있는 환경은 절대 하지 않기로 했습니다.  


AWS RDS와 Elastic Cache에 대한 통합 테스트를 작성하는데는 큰 문제가 없었습니다.

AWS SQS에 대한 격리된 테스트 환경이 필요했습니다.

우아한형제들에서는 자유롭게 AWS를 사용하고 테스트할 수 있게 **놀이터**라는 샌드박스 존이 존재합니다.  

![sqs테스트1](./images//sqs테스트1.png)

AWS의 메세징 큐 서비스인 SQS와 동일한 인터페이스를 가진 ElasticMQ를 Spring Boot에서 임베디드로 사용할 수 있게 랩핑한 라이브러리이다. 
즉, 의존성만 추가하면 H2 사용하듯이 SQS를 사용할 수 있게 해준다.


DB가 죽어도 적립/적립취소/사용취소 등은 처리되어야 한다
누락되는 요청 없이 언젠가는 요청이 처리된다
라는 2가지 전제조건을 처리하기 위해서 메세지 큐 서비스가 필수였고, 우린 AWS SQS를 선택했다. 
그러다보니 모든 기능은 SQS를 기반으로 구성해야만 했다. 
하지만 격리된 환경에서 사용할 Mock 제품이 없었다 
다른 서비스는 대체품이 존재했다.

* RDS : H2
* Elastic Cache Redis : Embedded Redis

헌데 SQS는 보편적인 Mock 솔루션이 없었다. 
개발용 AWS를 사용해선 안된다. 
모두가 접근할 수 있는 공용 저장소를 사용하는 순간 서로가 서로의 테스트를 침범하게 되어 격리된 테스트 환경 구축을 못하게 된다.
(내가 넣은 SQS 메세지를 다른 사람의 테스트에서 수신해버려서 내 테스트가 깨지는 등)

그래서 이런 Mock 제품이 필요하다고 생각을 했고, ElasticMQ가 SQS와 동일한 인터페이스를 제공한다는걸 발견하게 되서 Spring Boot에서 쉽게 사용할 수 있도록 랩핑하였다.

이렇게 라이브러리를 만들고 포인트 시스템 구축시에 사용해보니 로컬 개발하면서 한번도 서버를 실행해본적이 없다. 
모든걸 다 테스트 코드로만 실행하고 검증했다.

* 내가 만든 SQS Listner가 제대로 메세지를 수신하는지
* 내가 만든 QueueTemplate이 메세지를 제대로 송신하는지
* 내가 지정한 횟수만큼 실패시 Dead Letter Queue에 전달하는지
* 메세지가 원하는대로 JSON 전환되어 전달되는지

등등 Mocking으로 해결할 수 없는 테스트를 완전히 구현할 수 있었다.

브라우저로 테스트하는 것은 개발서버에 배포한 뒤에나 했다. 
근데 아무런 문제가 없었다. 
Spring Boot AWS Mock 을 기준으로 구현한 모든 코드들과 테스트 코드들이 실제 AWS 위에서도 의도한대로 잘 작동되었던 것이다.

이걸 계기로 AWS SQS도 테스트 코드를 작성할 수 있게 되었다. 
Jenkins에서 지속적으로 통합테스트를 수행할때도, 개발자 개개인의 로컬 PC에서 테스트를 수행할때도 서로 격리된 환경에서 SQS 관련 테스트 코드를 수행할 수 있게 되었다.


### 레거시 프로시저 테스트

신규 도메인은 모두 JPA를 사용하기 때문에 H2를 사용해도 문제가 없었습니다.  
하지만 기존 레거시 시스템의 프로시저를 검증하기 위한 테스트 코드를 작성하는데 문제가 있었습니다.  
H2는 MS SQL의 프로시저를 지원하지 않기 때문입니다.  

그래서 개인 PC에 **Docker로 MSSQL을 설치하고 기존 시스템의 프로시저를 모두 생성**했습니다.  


### HTTP API 테스트

일반적으로 **배포된 서비스의 HTTP API 테스트**는 Postman을 사용합니다.  
(배포전의 테스트는 당연히 단위 테스트 or 통합테스트 코드로 진행합니다.)  
  
저희는 팀 모두가 IntelliJ Ultimate 버전을 사용하고 있었기에 IntelliJ의 ```.http```를 사용하기로 결정했습니다.

* HTTP API 테스트를 버전 관리 가능
* HTTP API 스펙을 팀원 모두가 공유 가능

## API 문서 자동화

API 문서 자동화에 관한 솔루션들은 많습니다.

* Swagger
* Apidoc
* Spring Rest Docs

이 중에서 저희는 Spring Rest Docs를 선택했습니다.  
나머지 문서 자동화 솔루션들에는 개인적으로 생각하는 큰 단점들이 있었습니다.  

Apidoc의 경우 2가지 단점이 있었습니다.

* 문서를 사실상 수동으로 작성하는 것과 마찬가지라 문서와 코드가 따로 작동합니다 
* Apidoc을 위한 어노테이션이 프로덕션 코드를 오염시켰습니다

Swagger의 경우도 비슷한 단점이 존재했습니다.

* API를 테스트하기는 좋으나 Swagger 문서를 보고 연동 시스템을 만들기에는 부족한게 많습니다
* 프로덕션 코드가 Swagger 어노테이션으로 오염됩니다

반대로 Spring Rest Docs의 장점은 다음과 같습니다.

* 테스트 코드를 작성하면 문서로 자동 완성
    * 테스트 코드를 기준으로 문서가 만들어 지기에 프로덕션 코드에 관련된 코드가 전혀 필요 없음
    * 테스트 코드 기반이라 문서와 코드가 불일치하는 경우가 발생할수가 없음
* 테스트 코드로 표현하기 어려운 부분은 AsciiDoc 혹은 Markdown으로 작성 가능

Spring Rest Docs는 그간 제가 문서 자동화 솔루션들에 갖고 있던 불만을 모두 해결해주었습니다.  
즉, 테스트가 깨지면 문서가 만들어지지 않기 때문에 잘못된 API 문서가 발핼될일이 사전에 차단됩니다.  
  
다만 단점도 있었는데요.

* 테스트 코드로 문서를 표현해야하기에 Rest Docs용 테스트 코드의 양이 비정상적으로 많습니다.

RequestDto와 ResponseDto의 각 필드의 모든 명세를 작성해야만 했습니다.




Spring Rest Docs를 사용하는 방법은 크게 2가지가 있습니다.  
AsciiDoc과 Markdown입니다.  
처음 Rest Docs를 고려했을때는 Markdown 타입을 사용하려고 했습니다.  

Spring Rest Docs 사용 방법은 블로그에 정리했으니 참고하시면 좋을것 같습니다.

* [Spring Rest Docs를 Markdown으로 작성하기](https://jojoldu.tistory.com/289)
* [Spring Rest Docs를 AsciiDoc으로 작성하기](https://jojoldu.tistory.com/294)  



## 성능 테스트

성능 테스트의 경우 네이버에서 만든 Ngrinder와 Pinpoint를 사용했습니다.


* [성능 튜닝 #1 - DB Connection](https://jojoldu.tistory.com/318)
* [성능 튜닝 #2 - 리눅스 커널 파라미터](https://jojoldu.tistory.com/319)
* [성능 튜닝 #3 - Nginx](https://jojoldu.tistory.com/322)
* [성능 튜닝 #4 - Open Files & tcp_max_tw_buckets](https://jojoldu.tistory.com/323)
 
## QA

같은 TC (Test Case)로 2번 QA를 진행했습니다.  
이렇게 진행한 이유는 프로시저를 랩핑한 API와 신규 API 2개 모두가 테스트 되어야만 했기 때문입니다.  


## 배포


총 3단계로 진행했습니다.

1. 레거시 프로시저를 랩핑한 API 오픈
2. 레거시 API를 우선순위로 두고, 구 & 신 API 동시에 이벤트 발송하는 API로 전환
3. 신규 API를 우선순위로 두고, 구 & 신 API 동시에 이벤트 발송하는 API로 전환

### 레거시 프로시저를 랩핑한 API 오픈

7월 17일 레거시 프로시저를 랩핑한 API를 선오픈했습니다.  
그리고 차례로 그동안 포인트 프로시저를 사용했던 다른 시스템들이 API를 사용하는 패치가 진행되었습니다.  
  
1차 버전은 신규 API로 메시지가 발행되지 않는 버전이였습니다.  
실제 저

### 레거시 API 우선순위 API로 전환

모든 Endpoint가 프로시저가 아닌 저희가 랩핑한 API로 전환된 것을 확인하고, 일주일간 모니터링을 진행했습니다.  
그리고 7월 25일 2차 버전인 **레거시 API 우선순위 API로 전환**했습니다.  
즉, 프로시저가 성공하고 신규 API 가 실패하면 

대신 실패한 메세지는 로그로 Json 형태 그대로 남기게 하여, 매일 수동으로 다시 SQS로 재전송 하였습니다.  


### 신규 API 우선순위 API로 전환