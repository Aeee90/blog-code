# 2. 커버링 인덱스 (ORDER BY / WHERE + ORDER BY + GROUP BY)

### 2-3. WHERE + ORDER BY

ORDER BY 

### 2-4. ORDER BY + GROUP BY




### 2-5. WHERE + ORDER BY + GROUP BY

1. WHERE
2. GROUP BY
3. ORDER BY

## 커버링 인덱스의 장점

* 인덱스 항목은 일반적으로 전체 행 크기보다 훨씬 작으므로 인덱스 만 읽는 경우 MySQL이 훨씬 적은 데이터에 액세스 할 수 있습니다. 이는 응답 시간의 대부분이 데이터 복사에서 오는 캐시 된 워크로드에 매우 중요합니다. 인덱스는 데이터보다 작고 메모리에 더 적합하기 때문에 I / O 바운드 워크로드에도 유용합니다. (MyISAM의 경우 더욱 그렇습니다. 인덱스를 더 작게 만들기 위해 묶을 수 있습니다.)

* 인덱스는 인덱스 값에 따라 (적어도 페이지 내에서) 정렬되므로 I / O 바운드 범위 액세스는 임의의 디스크 위치에서 각 행을 페치하는 것보다 I / O를 덜 수행해야합니다. 

* 커버링 인덱스는 InnoDB의 클러스터형 인덱스 때문에 InnoDB 테이블에 특히 유용합니다. InnoDB의 2 차 인덱스는 리프 노드에서 행의 1 차 키 값을 보유합니다. 따라서 쿼리를 다루는 보조 인덱스는 기본 키에서 다른 인덱스 조회를 방지합니다.




## 커버링 인덱스 적용 순서

* 커버링 인덱스 적용 순서
  * WHERE 조건에 있는 컬럼 최우선
  * ORDER BY / GROPU BY / HAVING 컬럼 그 다음
  * SELECT 에 있는 컬럼을 마지막

> ```Using temporary;```?  
> [공식 문서](https://dev.mysql.com/doc/refman/8.0/en/internal-temporary-tables.html) 에선 다음과 같은 조건에서 임시 테이블을 만들 수 있다고 합니다.  
> ORDER BY 절과 다른 GROUP BY 절이 있거나 ORDER BY 또는 GROUP BY에 조인 큐의 첫 번째 테이블 이외의 테이블의 열이 포함 된 경우 임시 테이블이 작성됩니다.
> ORDER BY와 결합된 DISTINCT에는 임시 테이블이 필요할 수 있습니다.
