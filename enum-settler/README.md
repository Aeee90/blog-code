# Enum 활용기

안녕하세요? 우아한 형제들에서 결제/정산 시스템을 개발하고 있는 이동욱입니다.  
  
상반기 저희팀 최대 과제인 정산 플랫폼 개편을 진행함에 있어 저에게 큰 힘이 되었던 것 중 하나가 Enum이였습니다.  
이미 기존의 많은 블로그와 책에서 Enum의 정의와 기본적인 내용을 소개했기 때문에, 여기서 소개드릴 것은 "**프로젝트를 진행함에 있어 발생한 문제를 Enum을 통해 어떻게 해결했는가**" 입니다.  
어마어마한 비법이나 신기술을 담은 내용은 없지만, 보시는 분들에게 조금이나마 도움이 되었으면 하는 바램입니다.

> 나 : 선임님 코드 "card"는 뭔가요?  

> 선임님 : PG 결제에요

> 나 : 선임님 여기서 "card"도 PG죠?

> 선임님 : 아 여기선 카드결제에요

> 나 : ...?


(여기에서 사용된 코드는 실제 회사에서 사용한 코드는 아니며, 포스팅을 위해 별도 샘플로 작성한 코드임을 먼저 말씀드립니다.)  

## 들어가며

개발을 진행할때 Enum을 통해 얻는 기본적인 장점들은 아래와 같습니다.  

* 문자열과 비교해, **IDE의 적극적인 지원**을 받을 수 있다.
  * 자동완성, 오타검증, 텍스트 리팩토링 등등
* 허용 가능한 값들을 제한할 수 있다.
* **리팩토링시 변경 범위가 최소화** 된다.
  * 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다.

이 장점들은 직접적으로, 겉으로 드러나는 장점들입니다.  
Enum은 겉으로 드러나않는 장점들도 있습니다.  
예제로 하나씩 소개드리겠습니다.  

### 1. 데이터들 간의 연간관계 표현

여러 시스템과 연계되다보니 **동일한 데이터를 서로 다른 API 스펙에 맞춰** 전달받고 / 전달해야하는 경우가 있습니다.  
  
예를 들어 A API에서 상태값 "Y", "N"을 받아, 이를 B API에 "1", "0"으로 전달하고, C API에는 true, false로 전달하는 기능입니다.  
일반적으로는 if문과 메소드로 구현하게 됩니다.

![case1](./images/case1_legacy.png)

기능상의 문제는 없지만, 보시는것처럼 메소드로 추출해도 코드가 깔끔하지 않습니다.  
추가로 "Y", "1", true는 모두 **같은 의미**라는 것을 코드만으로 파악하는게 쉽지 않습니다.  
  
그래서 이 부분을 Enum으로 추출해보겠습니다.

![case1](./images/case1_enum.png)

"Y", "1", true 가 한 묶음으로, "N", "0", false가 한 묶음이 된 것을 코드로 바로 확인할 수 있습니다.  
이를 사용하는 곳에서도 역시 깔끔하게 표현이 가능합니다.  

![case1](./images/case1_test.png)

ApiStatus를 받아 필요한 곳에서 getXXX 메소드를 호출만 하면 됩니다.  
마찬가지로 DB에 "Y", "N"으로 저장되어있다면 이를 조회 


### 상태와 행위의 분리

서로 다른 계산식을 적용해야할 때가 있습니다.  
예를 들어 DB에 저장된 code의 값이 "CALC_A"일 경우엔 값 그대로, "CALC_B"일 경우엔 *10 한 값을, "CALC_C"일 경우엔 *3을 계산하여 전달해야만 합니다.  
가장 쉬운 해결 방법은 아래와 같이 static 메소드를 작성하여 필요한 곳에서 호출하는 방식일 것입니다.

![case2](./images/case2_legacy.png)




Calcualtor의 메소드와 code는 **서로 관계가 있음을 코드로 표현**할 수가 없습니다.  



### 타입별 연간관계

결제라는 데이터는 **결제 종류**와 **결제 수단**이라는 2가지 형태로 표현됩니다.  
예를 들어 신용카드 결제는 **신용카드 결제**라는 결제 수단이며, **카드 결제**라는 결제 종류에 포함됩니다.  
이 **카드 결제**는 페이코, 카카오페이등 여러 결제 수단이 포함되어 있다고 생각하시면 될것 같습니다.  


### Layer별 분리된 관리 포인트 - Enum Mapper

정산 플랫폼은 수많은 카테고리가 존재하기 때문에 UI에서 select box로 표현되는 부분이 많습니다.  

별도의 Bean으로 관리 포인트를 만들어두면 



## 마무리

A라는 상황에서 "a"와 B라는 상황에서 "a"는 전혀 다른 의미입니다.  
문자열은 이를 담을 수 없습니다.  
하지만 Enum은 **문맥(Context)을 담을 수 있습니다**.  
  
문맥을 코드로 표현할 수 있다는 것이 중요한것 같습니다.  
실행되는 코드를 이해하기 위해 **추가로 무언가를 찾아보는 행위를 최소화** 할 수 있기 때문입니다.   
이 코드의 의미와 용도를 파악하기 위해 컨플루언스를 검색하고, 엑셀과 워드 파일을 찾고, 레거시 테이블을 Join & Group by 하고, PHP 코드를 다시 찾는 과정이 정말 정말 **비효율적**이라고 생각하였습니다.  
(역설적이게도 해당 시스템을 가장 잘아시는분이 문서를 작성할 수록, **당연한 내용의 범위가 넓어** 누락되는 내용이 많아지고 이 과정이 더 많이 필요하게 됩니다.)  
  


